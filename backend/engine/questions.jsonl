{"id":1,"bloom":"Remember","difficulty":1,"question":"What is a variable in Python?","answer":"A variable is a named container that stores a value in memory","misconceptions":[]}
{"id":2,"bloom":"Remember","difficulty":2,"question":"What data type does the input() function return?","answer":"string (str)","misconceptions":[]}
{"id":3,"bloom":"Remember","difficulty":3,"question":"What is the difference between a list and a tuple in Python?","answer":"Lists are mutable (can be changed) and use square brackets [], while tuples are immutable (cannot be changed) and use parentheses ()","misconceptions":[]}
{"id":4,"bloom":"Understand","difficulty":1,"question":"Explain what happens when you write: x = 5","answer":"The value 5 is stored in memory and the variable name x is created to reference that memory location","misconceptions":[]}
{"id":5,"bloom":"Understand","difficulty":2,"question":"Why does '5' + '3' result in '53' instead of 8?","answer":"Because both values are strings, the + operator performs string concatenation (joining) rather than mathematical addition","misconceptions":[]}
{"id":6,"bloom":"Understand","difficulty":3,"question":"Explain why print(type(5/2)) shows <class 'float'> even though 5/2 = 2.5","answer":"The division operator / always returns a float in Python 3, even when dividing integers. This ensures precision is maintained in calculations","misconceptions":[]}
{"id":7,"bloom":"Apply","difficulty":1,"question":"Write code to swap the values of two variables a and b","answer":"temp = a; a = b; b = temp OR a, b = b, a (tuple unpacking)","misconceptions":[]}
{"id":8,"bloom":"Apply","difficulty":2,"question":"Write a function that takes a string and returns True if it's a palindrome","answer":"def is_palindrome(s): return s == s[::-1] OR use a loop to compare characters from both ends","misconceptions":[]}
{"id":9,"bloom":"Apply","difficulty":3,"question":"Write code that removes all duplicates from a list while preserving order","answer":"result = []; [result.append(x) for x in original if x not in result] OR use dict.fromkeys(original) or OrderedDict","misconceptions":[]}
{"id":10,"bloom":"Analyze","difficulty":2,"question":"Analyze: What's the output of print([1,2,3] * 2)?","answer":"[1, 2, 3, 1, 2, 3] - The * operator repeats the list, creating a new list with the elements duplicated","misconceptions":[]}
{"id":11,"bloom":"Analyze","difficulty":3,"question":"What's wrong with this code: def add_item(item, lst=[]): lst.append(item); return lst","answer":"Mutable default arguments are shared across function calls. Each call modifies the same list. Should use lst=None and create new list inside","misconceptions":[]}
{"id":12,"bloom":"Analyze","difficulty":4,"question":"Analyze the time complexity of checking if an element exists in a list vs a set","answer":"List: O(n) linear search through all elements. Set: O(1) average case using hash lookup. Sets are much faster for membership testing","misconceptions":[]}
{"id":13,"bloom":"Evaluate","difficulty":3,"question":"Evaluate: When should you use a dictionary instead of a list?","answer":"Use dictionaries when you need key-value pairs, fast lookups by key, or when data is naturally labeled. Use lists for ordered sequences where position matters","misconceptions":[]}
{"id":14,"bloom":"Evaluate","difficulty":4,"question":"Compare and contrast list comprehensions vs traditional for loops for filtering data","answer":"List comprehensions are more concise, often faster, and more Pythonic. For loops are better for complex logic, multiple operations, or when you need break/continue","misconceptions":[]}
{"id":15,"bloom":"Evaluate","difficulty":5,"question":"Justify whether to use recursion or iteration for calculating factorial of large numbers","answer":"Iteration is better for large numbers due to Python's recursion depth limit (~1000) and stack overflow risk. Recursion is elegant but impractical here without tail-call optimization","misconceptions":[]}